execute_pipeline:
    tasks = [@tasks.utils.set_seed,
             @tasks.load_data.load_dataset,
             @tasks.process_classes,
             @tasks.load_data.get_dataloaders,]
    execution_order = 'sequential'

tasks.utils.set_seed.seed=%SEED

train/torch.utils.data.DataLoader:
    shuffle=True
    batch_size=%TRAIN_BATCH_SIZE
    num_workers=%TRAIN_DATALOADER_NUM_WORKERS
    collate_fn=@tasks.load_data.dynamic_pad_batch

val/torch.utils.data.DataLoader:
    shuffle=False
    batch_size=%VAL_BATCH_SIZE
    num_workers=%VAL_DATALOADER_NUM_WORKERS
    collate_fn=@tasks.load_data.dynamic_pad_batch

pl.loggers.CSVLogger:
    save_dir=%OUTPUT_DIR
    name='pretrain_logs'

tasks.load_data.get_dataloaders.split_function=@tasks.load_data.dataset_random_split
tasks.load_data.get_dataloaders.dataset_cls={'train': @train/tasks.load_data.DictDataset, 'validation': @val/tasks.load_data.DictDataset}
tasks.load_data.get_dataloaders.dataloader_cls={'train': @train/torch.utils.data.DataLoader, 'validation': @val/torch.utils.data.DataLoader}

tasks.load_data.dataset_random_split:
    proportions={'train':-1,'validation':%VAL_SET_SIZE}

tasks.load_data.DictDataset.index_mapper=@tasks.load_data.compensate_lengths
tasks.load_data.compensate_lengths.chunk_length=%MAX_AUDIO_DURATION #This will sample long audios multiple times during one epoch (duration//compensate_framing times)

tasks.load_data.load_dataset.filters=[@tasks.load_data.remove_long_audios]
tasks.load_data.remove_long_audios.limit=%FILTER_AUDIO_LENGTH